[[comparing-indexing-models]]
== Comparing Indexing Models

Search systems such as Solr and Elasticsearch were originally designed for searching flat data, e.g., documents with a
set of attribute-value pairs, and not for searching nested data. A common fallback strategy is to rely on flattening.
However, flattening the data is error-prone and time-consuming. For this reason, Solr and Elasticsearch have recently
introduced a new feature, called
https://cwiki.apache.org/confluence/display/solr/Uploading+Data+with+Index+Handlers#UploadingDatawithIndexHandlers-NestedChildDocuments[Blockjoin] in Solr
and http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/mapping-nested-type.html[Nested Type] in
Elasticsearch,
to enable searching nested data. However, this feature is rooted in the
traditional flat model design, which results in limitations in performance and flexibility.
SIREn on the contrary has been designed from the ground up for searching schemaless nested data and does not suffer from
these limitations. In this section we will give a high level overview on how SIREn compares to other indexing models.

[float]
[[field-based-indexing-model]]
=== Field-Based Indexing

The field-based indexing model is the traditional model implemented in Lucene. To index nested data using this model,
it is necessary to first flatten the data prior to indexing. The flattening consists of creating a document field
for each path of attributes. For example, the json object below will produce the document as shown in
<<flat-document>>.

[source,javascript]
----
{
    "name": "Radar Networks",
    "location": {
        "city": "San Francisco",
        "state": "California"
    },
    "fundings": [
        {
            "round": "a",
            "investors": "NY Angels"
        },
        {
            "round": "b",
            "investors": "Sequoia"
        }
    ]
}
----

[[flat-document]]
.Flat model representation of a JSON object
image::images/flat-document.png["Flat model representation of a JSON object", align="center"]

This approach works fine with nested objects with a one-to-one relationship with the parent document, for example
with the +location+ nested object. The limitation of this approach occurs with one-to-many relationships between
the parent document and the nested objects. For example, if you try to search for documents which contains a nested object
matching `fundings.round: a AND fundings.investors: Sequoia`, the previous document will be returned which is a
false-positive match. Due to the flat representation, the system is not able to differentiate attribute matches between
nested objects and lose precision in the matching.

[float]
=== Blockjoin

The Blockjoin approach does not rely on flattening nested data. Instead, it internally creates one document per
nested objects and index them within the same "index block". For example, the previous JSON object will be represented
by four documents as shown in <<blockjoin-document>>. Documents within the same index block are related to each
other through a parent-child relationship. An index block enables to join documents with their parent document in
a very efficient manner. This approach solves the precision problem encountered with one to many relationships. However
a side-effect of Blockjoin is that it artificially increases the number of documents in the index.
The number of documents being generated by Blockjoin is proportional to the number of nested objects. This has a direct
consequence on the memory consumption and scalability of the system since the memory requirement of various caching
strategies is correlated with the number of documents in the index.

As we can see in <<blockjoin-document>>, Blockjoin needs to tag each document with an identifier, usually the attribute
path that leads to the nested object. This enables Blockjoin to differentiate between nested objects from different
paths and to avoid a loss of precision in the matching. This tag will be used at query time to filter out nested objects,
and it introduces a loss of performance during query processing. Another side-effect is that it forces the user
to know the exact path to the nested objects he wants to query, limiting the ability to query for nested objects without
knowing their path.

If you are interested in knowing more about the limitations in performance and scalability of the Blockjoin approach,
you can read our
http://siren.solutions/24-times-less-memory-11-times-faster-measuring-the-impact-of-siren-on-elasticsearch-and-solr-systems/[whitepaper]
which benchmarks Blockjoin and SIREn on a patent search scenario.

[[blockjoin-document]]
.Blockjoin representation of a JSON object
image::images/blockjoin-document.png["Blockjoin representation of a JSON object", align="center"]

[float]
=== SIREn

SIREn adopts a generic tree model to represent nested data and semi-structured information.
Each document in SIREn is represented as a tree, as pictured in <<siren-document>>. The root node of the tree
represents the top-level object. The child nodes of the root represent the attributes associated to the top-level
object. The child nodes of an attribute node represent the values associated
to this attribute. A value can either be a primitive value (string, numeric or boolean), a nested object or an array
of values.

[[siren-document]]
.SIREn representation of a JSON object
image::images/siren-document.png["SIREn representation of a JSON object", align="center"]

Compared to Blockjoin, SIREn does not artificially increase the number of documents in the index, since the full
tree is encoded within one single document. As a result, the memory consumption and scalability of the system
is not affected by the number of nested objects in the data. To achieve this, SIREn uses its own index format
with very efficient compression and encoding schemes to store and index the tree structure within a single document.

SIREn indexing model enables more advanced search capabilities than Blockjoin. Given that the encoded tree model
keeps the ordering of the nodes, it becomes possible to design a search query that will take into account the
proximity of the nodes, e.g., searching for nested objects that occurs next to each other or at two positions apart.
It is also possible to search for nested objects without knowing their full path from the root node, i.e., a wildcard
path search.

There are also other advantages such as the support for precise search of multi-valued attributes, or the ability to
analyze and search attribute names as any other textual content.
